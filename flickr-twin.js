'use strict';
//This file was automatically generated by compile.sh from flickr-twin-template.js

'use strict';

// eslint-disable-next-line no-unused-vars
class FlickrAPI {
    /**
     * Create the api wrapper
     * @param {string} api_key - (optional) If omitted, attempts to read saved value from localstorage 
     */
    constructor(api_key) {
        if (api_key) {
            this.setAPIKey(api_key);
        } else if (window.localStorage["api_key"]) {
            this.api_key = window.localStorage["api_key"];
        }
        if (window.localStorage["call_history"]) {
            this.call_history = JSON.parse(window.localStorage["call_history"]);
        } else {
            this.call_history = [];
        }
    }

    /**
     * Return the string representation of the object, e.g.
     * "83a16800e347e711938a038fd642fc2d": Used 1/3500 calls this hour. Oldest call expires in 00:42:42
     * @returns {string}
     */
    toString() {
        if (this.api_key) {
            const calls = this.getNumberOfAPICalls();
            let returnValue = `"${this.api_key}": Used ${calls}/3500 calls this hour.`;
            if (calls > 0) {
                const ms_until_call_expires = this.call_history[0] + 60 * 60 * 1000 - Date.now();
                const time_formatted = new Date(ms_until_call_expires).toISOString().substr(11, 8);
                returnValue += ` Oldest call expires in ${time_formatted}`;
            }
            return returnValue;
        } else {
            return "No API key set";
        }
    }

    log() {
        console.log(this.toString());
    }

    setAPIKey(api_key) {
        this.api_key = api_key;
        window.localStorage["api_key"] = api_key;
    }

    /**
     * Returns the number of (recorded) times the api key has been used this hour
     * @returns {number}
     */
    getNumberOfAPICalls() {
        const one_hour_ago = Date.now() - 60 * 60 * 1000;
        while (this.call_history[0] < one_hour_ago) {
            this.call_history.shift();
        }
        return this.call_history.length;
    }

    /**
     * Called before an api call to check that the key is valid and under limit, 
     * and then increment the hourly count
     */
    useAPI() {
        if (!(this.api_key && this.api_key.length > 5)) {
            throw new Error("No API key set");
        }
        if (this.getNumberOfAPICalls() > 3500) {
            throw new Error("Exceeded API limit for this key");
        }
        this.call_history.push(Date.now());
        window.localStorage["call_history"] = JSON.stringify(this.call_history);
    }

    /**
     * https://www.flickr.com/services/api/flickr.photos.getFavorites.html
     * Returns a json object with a list of people who have favorited a given photo.
     * See doc/api-examples/flickr.photos.getFavorites.json for an example.
     * @param {string} photo_id - The ID of the photo to fetch the favoriters list for.
     * @param {number} page - The page of results to return. If this argument is omitted, it defaults to 1.
     * @returns {Object} - Parsed version of the json response
     */
    async getImageFavorites(photo_id, page = 1) {
        this.useAPI();
        const baseurl = "https://www.flickr.com/services/rest/?format=json&nojsoncallback=1";
        const method = "&method=flickr.photos.getFavorites&per_page=50";
        const rest_url = `${baseurl}${method}&photo_id=${photo_id}&page=${page}&api_key=${this.api_key}`;
        const rest_response = await fetch(rest_url);
        const response_json = await rest_response.json(); //extract JSON from the http response
        return response_json;
    }

    /**
     * https://www.flickr.com/services/api/flickr.favorites.getPublicList.html
     * Returns a json object with a list of favorite public photos for the given user.
     * See doc/api-examples/flickr.favorites.getPublicList.json for an example.
     * @param {string} user_id - The user to fetch the favorites list for.
     * @param {number} page - The page of results to return. If this argument is omitted, it defaults to 1.
     * @returns {Object} - Parsed version of the json response
     */
    async getUserFavorites(user_id, page = 1) {
        this.useAPI();
        const baseurl = "https://www.flickr.com/services/rest/?format=json&nojsoncallback=1";
        const method = "&method=flickr.favorites.getPublicList&per_page=500";
        const rest_url = `${baseurl}${method}&user_id=${user_id}&page=${page}&api_key=${this.api_key}`;
        const rest_response = await fetch(rest_url);
        const response_json = await rest_response.json(); //extract JSON from the http response
        return response_json;
    }

    /**
     * https://www.flickr.com/services/api/flickr.photos.getInfo.html
     * Returns a json object with information about a photo.
     * See doc/api-examples/flickr.photos.getInfo.json for an example.
     * @param {string} photo_id - The id of the photo to get information for.
     * @returns {Object} - Parsed version of the json response
     */
    async getPhotoInfo(photo_id) {
        this.useAPI();
        const baseurl = "https://www.flickr.com/services/rest/?format=json&nojsoncallback=1";
        const method = "&method=flickr.photos.getInfo";
        const rest_url = `${baseurl}${method}&photo_id=${photo_id}&api_key=${this.api_key}`;
        const rest_response = await fetch(rest_url);
        const response_json = await rest_response.json(); //extract JSON from the http response
        return response_json;
    }
}

'use strict';

/**
 * Base class for UserDatabase and ImageDatabase
 */
class FavesDatabase {
    constructor() {
        this.db = {};
    }

    /**
     * Returns true if the db contains the specified id
     * @param {string} id 
     * @returns {boolean}
     */
    has(id) {
        return this.db[id] !== undefined;
    }

    /**
     * Get an object from db
     * @param {string} id 
     * @returns {object}
     */
    get(id) {
        return this.db[id];
    }

    /**
     * Set the value of the specified id
     * @param {string} id 
     * @param {object} value 
     */
    set(id, value) {
        this.db[id] = value;
    }

    /**
     * Returns an Array containing the all keys (ids) in the db
     * @returns {Array}
     */
    keys() {
        return Object.keys(this.db)
    }
    
    /**
     * Returns an Array containing the all values in the db
     * @returns {Array}
     */
    values() {
        return Object.values(this.db)
    }

    /**
     * Returns an Array of [key, value] pairs for each item in the db
     * @returns {Array} 
     */
    entries() {
        return Object.entries(this.db)
    }

    /**
     * Returns an Array of the contents of the db, sorted by fave count (highest first)
     * @param {number} max_count - Maximum number of items in the list. If omitted, returns the whole list.
     * @param {number} starting_from - Index to start from when slicing the list (for pagination). Defaults to 0.
     * @returns {Array} - The sorted Array
     */
    sortedList(max_count, starting_from = 0) {
        const end = max_count ? starting_from + max_count : undefined;
        return this.values()
            .sort((a, b) => { return b.favecount - a.favecount; })
            .slice(starting_from, end);
    }

    /**
     * Returns an Array of the contents of the db, sorted by fave count (highest first), excluding exclude_list
     * @param {Array | Set} exclude_list - Set or list of items to exclude from the list. 
     * @param {number} max_count - Maximum number of items in the list. If omitted, returns the whole list.
     * @param {number} starting_from - Index to start from when slicing the list (for pagination). Defaults to 0.
     * @returns {Array} - The sorted Array
     */
    sortedListExcluding(exclude_list, max_count, starting_from = 0) {
        const end = max_count ? starting_from + max_count : undefined;
        return this
            .excluding(exclude_list)
            .sort((a, b) => { return b.favecount - a.favecount; })
            .slice(starting_from, end);
    }

    /**
     * @returns {Object} - The internal database, with insignificant members trimmed off.
     */
    trimmedDB(min_faves = 2) {
        let newdb = {};
        for (const key of this.keys()) {
            if (this.get(key).favecount >= min_faves) {
                newdb[key] = this.get(key);
            }
        }
        return newdb;
    }

    /**
     * 
     * @param {Array | Set} exclude_list - Set or list of items to exclude from the list. 
     * @returns {Array} - A new array containing that members of the db, excluding above
     */
    excluding(exclude_list) {
        let exclude_set
        if (exclude_list instanceof Array) {
            exclude_set = new Set(exclude_list)
        } else if (exclude_list instanceof Set) {
            exclude_set = exclude_list;
        } else {
            throw (new TypeError("exclude_list must be an array or set"))
        }
        return this.values().filter(
            (item) => !exclude_set.has(item.id || item.nsid)
        )
    }

    /**
     * Copy db to localstorage (may be too large)
     */
    store() {
        window.localStorage[this.storageKey] = JSON.stringify(this.db);
    }

    /**
     * Load db from localstorage
     */
    load() {
        this.db = JSON.parse(window.localStorage[this.storageKey]);
    }
}

// eslint-disable-next-line no-unused-vars
class UserDatabase extends FavesDatabase {
    constructor() {
        super();
        this.storageKey = "udb";
        // TODO get old value from localstorage
    }

    addPerson(person) {
        this.set(person.nsid, {
            nsid: person.nsid,
            realname: person.realname,
            username: person.username,
            buddyicon: person.iconserver > 0 ?
                `http://farm${person.iconfarm}.staticflickr.com/${person.iconserver}/buddyicons/${person.nsid}.jpg` :
                "https://www.flickr.com/images/buddyicon.gif",
            faves: {},
            favecount: 0,
        });
    }

    add(json_response) {
        if (json_response.stat !== "ok") {
            console.log(json_response.stat);
            return;
        }
        const people = json_response.photo.person;
        const photo_id = json_response.photo.id;
        for (const person of people) {
            const nsid = person.nsid;
            if (!this.has(nsid)) {
                this.addPerson(person);
            }
            if (this.get(nsid).faves[photo_id]) {
                continue;
            }
            this.get(nsid).faves[photo_id] = person.favedate;
            this.get(nsid).favecount += 1;
        }
    }
}

// eslint-disable-next-line no-unused-vars
class ImageDatabase extends FavesDatabase {
    constructor() {
        super();
        this.storageKey = "idb";
        // TODO get old value from localstorage
    }

    addPhoto(photo) {
        const owner = typeof photo.owner == "string" ? photo.owner : photo.owner.nsid;
        this.set(photo.id, {
            id: photo.id,
            owner: owner,
            secret: photo.secret,
            server: photo.server,
            url: `https://www.flickr.com/photos/${owner}/${photo.id}/`,
            imgUrl: `https://live.staticflickr.com/${photo.server}/${photo.id}_${photo.secret}_m.jpg`,
            faved_by: [],
            favecount: 0,
        });
    }

    add(json_response, opts={}) {
        if (json_response.stat !== "ok") {
            console.log(json_response.stat);
            return;
        }
        //flickr.photos.getInfo
        if (json_response.photo && !this.has(json_response.photo.id)) {
            this.addPhoto(json_response.photo);
        } else { //flickr.favorites.getPublicList
            const photos = json_response.photos.photo;
            for (const photo of photos) {
                const id = photo.id;
                if (!this.has(id)) {
                    this.addPhoto(photo);
                }
                this.get(id).favecount += 1;
                if (opts.user_id) {
                    this.get(id).faved_by.push(opts.user_id)
                }
            }
        }
    }
}

'use strict';

// eslint-disable-next-line no-unused-vars
class Renderer {
    constructor(controller) {
        this.c = controller;
        this.idb = controller.idb;
        this.udb = controller.udb;
        this.renderParent = null;
        this.displaying = null;
        // Left and right arrow key pagination
        document.addEventListener("keydown", this.paginationKeypressHandler.bind(this))
    }

    /**
     * Clears the render area, or the body if none is assigned
     * @returns {Renderer} A reference to the calling object
     */
    clear() {
        if (!(this.renderParent instanceof Element)) {
            this.renderParent = null
            console.warn("Warning: r.renderParent was not instanceof Element, setting to null")
        }
        if (this.renderParent == null) {
            this.renderParent = document.body;
        }
        this.renderParent.innerHTML = "";
        return this;
    }

    /**
     * Appends HTML to the render parent node
     * @param {string} newHTML 
     * @returns {Renderer} A reference to the calling object
     */
    appendHTML(newHTML) {
        this.renderParent.innerHTML += newHTML;
        return this;
    }

    /**
     * Render the next page in a paginated display
     */
    next() {
        if (this.displaying.page >= this.displaying.max_page) {
            return;
        }
        this.displaying.page += 1;
        this.displaying.f.call(this, this.displaying)
    }

    /**
     * Render the previous page in a paginated display
     */
    previous() {
        if (this.displaying.page <= 1) {
            return;
        }
        this.displaying.page -= 1;
        this.displaying.f.call(this, this.displaying)
    }

    /**
     * Render the specified page in a paginated display
     * @param {number | string} page 
     */
    gotoPage(page) {
        this.displaying.page = page;
        this.displaying.f.call(this, this.displaying)
    }

    /**
     * Print the top result for user twins to the console
     * @param {number} max_count - Number of users to print
     */
    print_results(max_count = 30) {
        let twins_list = this.udb.sortedList(max_count);

        for (const twin of twins_list) {
            const favecount = twin.favecount;
            const name = twin.realname ? twin.realname : twin.username;
            const nsid = twin.nsid;
            console.log(`${favecount}: ${name} (https://www.flickr.com/photos/${nsid}/favorites)`);
        }
    }

    displayImages(opts = {}) {
        const defaultOpts = {
            page: 1,
            per_page: 20
        };
        // Merge opts with default ops
        opts = { ...defaultOpts, ...opts };
        // Assign images
        let images = opts.images
        if (images == null) {
            if (opts.ids) {
                images = [...opts.ids].map(id => this.idb.get(id))
                opts.mode = "by_id"
            } else if (opts.excluding || opts.mode == "excluding") {
                images = this.idb.sortedListExcluding(this.c.getHidden());
                opts.mode = "excluding"
            } else if (opts.all || opts.mode == "all") {
                images = this.idb.sortedList()
                opts.mode = "all"
            } else {
                images = this.idb.sortedListExcluding(this.c.getHidden())
                const minfavecount = images[0].favecount / 5
                if (images[0].favecount > 2) {
                    images = images.filter(i => i.favecount > minfavecount);
                }
                opts.mode = "default"
            }
        }
        // Extract variables
        const per_page = Number(opts.per_page);
        opts.page = Number(opts.page);
        const cur = opts.page;
        const max = Math.ceil(images.length / per_page);
        opts.max_page = max;
        const images_onscreen = images.slice(per_page * (cur - 1), per_page * cur);
        // Render
        this.addImageCSS()
        this.addPaginationCSS()
        this.clear()
        this.renderPagination(cur, max)
        this.renderImages(images_onscreen)
        this.renderPagination(cur, max)
        // Set state
        this.displaying = { ...opts, f: this.displayImages, images: images, images_onscreen: images_onscreen }
    }

    /**
     * Add CSS to the document for styling the image view
     */
    addImageCSS() {
        if (document.getElementById("flickr-twin-img-css") == undefined) {
            document.head.innerHTML +=
                `<style id="flickr-twin-img-css">
                    .img-container {
                        margin: 5px;
                        background: rgba(84,91,94,.5);
                    }
                    .flex {
                        display: flex;
                        flex-wrap: wrap;
                    }
                </style>`;
        }
    }

    /**
     * Return the html represention of a given image
     * @param {Object} img - An object representing a Flickr image, with the following properties:
     *      imgUrl - Url leading to the image file at a thumbnail resolution 
     *          (`https://live.staticflickr.com/${photo.server}/${photo.id}_${photo.secret}_m.jpg`)
     *      url - Url of the image page 
     *          (`https://www.flickr.com/photos/${owner.nsid}/${photo.id}/`)
     *      favecount (optional) - Number of faves (by processed users) the image has received 
     * @returns {string} - A string of the html to display the given object
     */
    imageHTML(img) {
        return `<a href="${img.url}">
                <div class="img-container">
                    <div><img src="${img.imgUrl}"></div>
                    <div>${img.favecount ? img.favecount + " faves" : ""}</div>
                </div>
                </a>`;
    }

    /**
     * Renders each of the given images in the render area
     * @param {Array} image_list - List of images to display
     * @returns {Renderer} - A reference to this Renderer
     */
    renderImages(image_list) {
        this.addImageCSS();
        let newHTML = `<div class="flex">`;
        for (const img of image_list) {
            newHTML += this.imageHTML(img);
        }
        this.appendHTML(newHTML + `</div>`);
        return this;
    }

    displayImagesByIDs(id_list) {
        const image_list = id_list.map(id => this.idb.get(id)).filter(img => img != null);
        this.displaying = { images: image_list }
        this.clear().renderImages(image_list);
    }

    /**
     * Returns an array representing which page buttons to display, similar to the way Flickr
     *  shows pagination. Always displays the first two pages, 7 pages adjacent to the current page,
     *  and the last two pages. Omitted pages are represented by a single item of "-1"
     * @param {number} cur - Current page 
     * @param {number} max - Total number of pages
     * @returns {Array} - Array of numbers
     */
    paginationArray(cur, max) {
        const pagelist = []
        // Flank the current page by 3 adjacent pages, except at the beginning and end
        const curLeftFlank = Math.min(cur - 3, max - 6)
        const curRightFlank = Math.max(cur + 3, 7)
        for (let i = 1; i <= max; i++) {
            if (i > 2 && i < curLeftFlank) {
                i = curLeftFlank;
                pagelist.push(-1) //converted to dots
            } else if (i > curRightFlank && i < max - 2) {
                i = max - 1
                pagelist.push(-1) //converted to dots
            }
            pagelist.push(i)
            if (pagelist.length > max) break;
        }
        return pagelist
    }

    /**
     * Returns the html to display pagination buttons
     * @param {number} cur - Current page 
     * @param {number} max - Total number of pages
     * @returns {string} - Pagination HTML
     */
    paginationHTML(cur, max) {
        let newHTML = `<div class="pagination-view">`
        // Left arrow
        if (cur > 1) { // Don't display on first page
            newHTML +=
                `<a href="#" rel="prev" data-page="previous">
                    <span><i class="page-arrow"></i></span>
                </a>\n`
        } else {
            newHTML += `<span class="disabled"><i class="page-arrow"></i></span>`
        }
        // Numbered buttons
        for (const pagenum of this.paginationArray(cur, max)) {
            if (pagenum >= 1) { // Real page
                newHTML +=
                    `<a href="#" data-page="${pagenum}">
                        <span${pagenum == cur ? ` class="is-current"` : ``}>${pagenum}</span>
                    </a>\n`
            } else { // -1, i.e. dots
                newHTML += `<span class="moredots">•••</span>\n`
            }
        }
        // Right arrow
        if (cur < max) { // Don't display on last page
            newHTML +=
                `<a href="#" rel="next" data-page="next">
                    <span><i class="page-arrow right"></i></span>
                </a>`
        } else {
            newHTML += `<span class="disabled"><i class="page-arrow right"></i></span>`
        }
        return newHTML + `</div>`;
    }

    /**
     * Attach listeners and handlers to each pagination button
     */
    addPaginationListeners() {
        for (const a of document.querySelectorAll(".pagination-view a")) {
            a.addEventListener('click', this.paginationClickHandler.bind(this))
        }
    }

    /**
     * Handle clicks on pagination buttons
     * @param {MouseEvent} event - The triggering mouse click
     */
    paginationClickHandler(event) {
        let elem = event.target;
        while (elem.dataset.page == undefined) {
            elem = elem.parentElement;
        }
        const page = elem.dataset.page;
        if (page == 'next') {
            this.next()
        } else if (page == 'previous' || page == 'prev') {
            this.previous()
        } else if (page >= 1) {
            this.gotoPage(page)
        }
    }

    /**
     * Handles pagination using the left and right arrow keys
     * @param {KeyboardEvent} event - The triggering keydown event
     */
    paginationKeypressHandler(event) {
        const key = event.key;
        if (key == "ArrowRight") {
            this.next()
        } else if (key == "ArrowLeft") {
            this.previous()
        }
    }

    /**
     * Renders the pagination for the current display
     * @param {number} cur - Current page 
     * @param {number} max - Total number of pages
     * @returns {Renderer} - A reference to this Renderer
     */
    renderPagination(cur, max) {
        this.appendHTML(this.paginationHTML(cur, max));
        this.addPaginationListeners()
        return this;
    }

    /**
     * Add CSS to the document for styling the pagination buttons
     */
    addPaginationCSS() {
        if (document.getElementById("flickr-twin-page-css") == undefined) {
            document.head.innerHTML +=
                `<style id="flickr-twin-page-css">
                    .pagination-view {
                        margin: 10px auto;
                        text-align: center;
                        min-height: 20px;
                    }
                    
                    .pagination-view a {
                        text-decoration-color: initial;
                    }
                    
                    .pagination-view a {
                        text-decoration: none;
                        display: inline-block;
                        border-radius: 3px;
                    }
                    
                    .pagination-view span {
                        color: rgb(157, 149, 136);
                    }
                    
                    .pagination-view span {
                        display: inline-block;
                        box-sizing: border-box;
                        min-width: 32px;
                        height: 32px;
                        padding: 0 10px;
                        line-height: 32px;
                        color: #898989;
                        text-align: center;
                        border-radius: 3px;
                        cursor: pointer;
                        vertical-align: top;
                        transition: background-color .15s ease-in-out;
                    }
                    
                    .pagination-view span.is-current {
                        background-image: initial;
                        background-color: rgb(0, 113, 178);
                        color: rgb(232, 230, 227);
                    }
                    
                    .pagination-view span.is-current {
                        background: #008ddf;
                        color: #fff;
                        font-weight: 600;
                    }
                    
                    .pagination-view a:hover span {
                        box-shadow: rgb(0, 113, 178) 0px 0px 0px 2px inset;
                    }
                    
                    .pagination-view i {
                        display: inline-block;
                        position: relative;
                        top: 3px;
                    }
                    
                    .pagination-view .page-arrow {
                        background: url(https://combo.staticflickr.com/ap/build/images/sprites/icons-cc4be245.png) -542px -334px no-repeat;
                        width: 8px;
                        height: 18px;
                    }
                    
                    .pagination-view .page-arrow.right {
                        -webkit-transform: rotate(180deg);
                        transform: rotate(180deg);
                    }

                    .pagination-view .disabled .page-arrow {
                        display: none;
                    }
                </style>`;
        }
    }
}

'use strict';

// eslint-disable-next-line no-unused-vars
class Controller {
    constructor() {
        /* eslint-disable no-undef */
        this.api = new FlickrAPI();
        this.udb = new UserDatabase();
        this.idb = new ImageDatabase();
        this._processed_images = new Set();
        this._excluded = new Set();
        this._hidden = new Set();
        this.r = new Renderer(this);
        /* eslint-enable no-undef */
    }

    async processPhotos(photo_ids) {
        const progress = new Progress(photo_ids.length);
        for (const photo_id of photo_ids) {
            if (this._processed_images.has(photo_id)) {
                progress.duplicate(photo_id);
                continue;
            }
            this._processed_images.add(photo_id);
            //Load the first page of faves for each image, get total number of pages
            progress.await(this.api.getImageFavorites(photo_id).then((response) => {
                const pages = response.photo.pages;
                console.log("%s: %s pages", photo_id, pages) //TODO remove debugging info
                progress.updatePages(pages)
                // Load each subpage
                for (let p = 2; p <= pages; p++) {
                    progress.awaitSub(this.api.getImageFavorites(photo_id, p).then((response) => {
                        this.udb.add(response);
                        progress.subUpdate(`${photo_id} ${p}`); //TODO remove debugging info
                    }));
                }
                this.udb.add(response);
                progress.update(`${photo_id} ${1}`); //TODO remove debugging info
            }).catch(error => {
                this._processed_images.delete(photo_id)
                progress.error(photo_id, error)
            }));
        }
        // Wait for all the api call promises to settle
        await progress.allSettled()
        progress.done();
    }

    async processUsers(user_ids) {
        const progress = new Progress(user_ids.length);
        for (const user_id of user_ids) {
            progress.await(this.loadUser(user_id, {progress: progress}))
        }
        // Wait for all the api call promises to settle
        await progress.allSettled();
        progress.done();
    }

    async loadUser(user_id, opts = {}) {
        const progress = opts.progress || new Progress(1)
        const idb = opts.idb || this.idb
        // Load the first page of faves for each user, get the total number of pages
        await this.api.getUserFavorites(user_id).then((response) => {
            const pages = Math.min(response.photos.pages, opts.max_pages || 50);
            if (response.photos.pages > 50) {
                console.warn(`user ${user_id} has more than 50 pages of favorites`)
            }
            progress.updatePages(pages);
            // Load each subpage
            for (let i = 2; i <= pages; i++) {
                progress.awaitSub(this.api.getUserFavorites(user_id, i).then((response) => {
                    idb.add(response, { user_id: user_id });
                    progress.subUpdate()
                }))
            }
            idb.add(response, { user_id: user_id });
            progress.update();
        }).catch(error => {
            progress.error(user_id, error)
        })
        if (!opts.progress) {
            progress.done()
        }
        return idb;
    }

    async processPhotosFromUser(user_id) {
        // Done in one step to allow idb to be garbage collected immediately
        const photo_ids = (await this.loadUser(user_id)).keys()  
        await this.processPhotos(photo_ids)
    }

    async processUsersFromDB(num = 20) {
        const users = this.udb.sortedList(num).map(user => user.nsid)
        await this.processUsers(users);
    }

    /**
     * Make sure the specified photos are loaded into idb so you can display them
     * Uses api.getPhotoInfo() (flickr.photos.getInfo)
     * @param {Array} photo_ids - List of photo ids to load
     */
    async loadPhotos(photo_ids) {
        const progress = new Progress(photo_ids.length)
        for (const photo_id of photo_ids) {
            if (!this.idb.has(photo_id)) {
                progress.await(this.api.getPhotoInfo(photo_id).then(response => {
                    this.idb.add(response)
                    progress.update()
                }).catch(() => {
                    progress.error(photo_id)
                }))
            } else {
                progress.duplicate()
            }
        }
        await progress.allSettled()
        progress.done()
    }

    /**
     * Exclude ids from the process
     * @param {Iterable} list - List of ids to exclude
     */
    exclude(list) {
        for (const i of list) {
            this._excluded.add(i);
        }
    }

    /**
     * Hide ids from being displayed by the renderer
     * @param {Iterable} list - List of ids to hide
     */
    hide(list) {
        for (const i of list) {
            this._hidden.add(i);
        }
    }

    /**
     * @returns {Set} - Set of all the ids which should be hidden
     */
    getHidden() {
        return new Set([...this._processed_images, ...this._excluded, ...this._hidden])
    }

    /**
     * Returns true if the given id should be hidden
     * @param {string} id - Photo id to check 
     * @returns {boolean}
     */
    isHidden(id) {
        return this._processed_images.has(id) || this._excluded.has(id) || this._hidden.has(id)
    }
}

class Progress {
    constructor(total_inputs) {
        this.number_of_inputs = total_inputs;
        this.total_inputs = total_inputs;
        this.inputs_processed = 0;
        this.total_pages = total_inputs;
        this.pages_processed = 0;
        this.duplicates = 0;
        this.errors = 0;
        this.awaited = [];
        this.awaitedSub = [];
    }

    toString() {
        return `${this.inputs_processed}/${this.total_inputs} : ${this.pages_processed}/${this.total_pages}`
    }

    log(msg) {
        if (msg) {
            console.log("%s (%s)", this.toString(), msg);
        } else {
            console.log(this.toString());
        }
    }

    updatePages(pages) {
        // in some cases, there can be zero pages of results
        if (pages) {
            // 1 page is already accounted for 
            this.total_pages += pages - 1;
        }
    }

    update(msg) {
        this.inputs_processed += 1;
        this.pages_processed += 1;
        this.log(msg)
    }

    subUpdate(msg) {
        this.pages_processed += 1;
        this.log(msg)
    }

    duplicate(input_id) {
        this.duplicates += 1;
        this.total_inputs -= 1;
        this.total_pages -= 1;
        if (input_id) {
            console.warn(`${input_id} already processed`);
        }
    }

    error(input_id, msg) {
        this.errors += 1
        if (input_id) {
            console.error(`Error processing ${input_id}${msg ? ": " + msg : ""}`);
        }
    }

    /**
     * Collects promises from primary api calls
     * @param {Promise} promise 
     */
    await(promise) {
        this.awaited.push(promise)
    }

    /**
     * Collects promises from secondary api calls
     * @param {Promise} promise 
     */
    awaitSub(promise) {
        this.awaitedSub.push(promise)
    }

    /**
     * @returns {Promise} - Resolves when all collected api call promises have resolved/failed
     */
    async allSettled() {
        // Wait for all the page 1's...
        await Promise.allSettled(this.awaited)
        // ...and then for all the other pages
        await Promise.allSettled(this.awaitedSub)
    }

    /**
     * Log that the task has been completed
     */
    done() {
        let msg = `Done. Processed ${this.inputs_processed}/${this.number_of_inputs} items`
        if (this.duplicates) {
            msg += ` with ${this.duplicates} duplicates`
        }
        console.log(msg + ".");
    }
}

// eslint-disable-next-line no-undef
const c = new Controller()
c.api.log()
